import {
  DataTypes,
  HasManyAddAssociationMixin,
  HasManyCreateAssociationMixin,
  HasManyGetAssociationsMixin,
  HasManyHasAssociationMixin,
  Model,
  ModelAttributes,
  Sequelize,
} from 'sequelize'
import { Character } from '.'
import { omit } from '../utils'
import { AutoGeneratedAttrs } from './utils'

export interface UserAttrs extends AutoGeneratedAttrs {
  username: string
  password: string
}
export type UserAttrsOnlyDefine = Omit<UserAttrs, keyof AutoGeneratedAttrs>
export type UserCreateAttrs = UserAttrsOnlyDefine

interface UserModel extends Model<UserAttrs, UserCreateAttrs>, UserAttrs {
  createCharacter: HasManyCreateAssociationMixin<Character>
  addCharacter: HasManyAddAssociationMixin<Character, Character['id']>
  getCharacters: HasManyGetAssociationsMixin<Character>
  hasCharacter: HasManyHasAssociationMixin<Character, Character['id']>
}

export function defineUserModel(sequelize: Sequelize) {
  const attrs: ModelAttributes<UserModel, UserAttrsOnlyDefine> = {
    username: {
      type: DataTypes.STRING,
      unique: true,
    },
    password: DataTypes.STRING,
  }
  const modelCtor = class User extends sequelize.define('User', attrs) {
    // Populated for inclusions
    // public readonly Classes?: Class[]
    // public static associations: {
    //     Classes: Association<Student, Class>
    // }

    toClient() {
      return omit(this.toJSON(), 'password')
    }
  }

  // 这个模拟 sequelize.define 对于 class 的处理是为了防止出现一些奇怪的问题，比如 hasMany 无效。
  modelCtor.init(
    // TODO: 这里需要 as 下，不知道是 sequelize 的类型有问题，还是我用法不对。
    // 如果是用法不对，可能是 UserAttrs 不能继承自 AutoGeneratedAttrs？
    attrs as ModelAttributes<UserModel, UserAttrs>,
    {
      modelName: modelCtor.name,
      sequelize,
    }
  )

  return modelCtor
}
